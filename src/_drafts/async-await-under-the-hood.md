---
layout: post
title: Async/await "под капотом" и как его готовить
categories: python
comments: true
---
## О чем эта статья?
В этой статье мы разберем, что представляет собой [`async`/`await` в Python 3.5](https://docs.python.org/3/whatsnew/3.5.html#whatsnew-pep-492), как он устроен и что нужно знать, чтобы правильно писать асинхронные программы. Статья будет полезна разработчикам, которые ранее уже писали многопоточные программы, но ещё не успели попробовать `async`/`await`, а также тем, кто про них пока только слышал. В статье будут встречаться ссылки на PEP и прочие документы, очень рекомендую с ними ознакомиться, поскольку охватить в статье всё не представляется возможным, а PEP'ы написаны очень подробно.

## Генераторы - основа всего
Чтобы понять, почему вообще появился `async`/`await`, нам необходимо вернуться в прошлое и вспомнить, как развивалось асинхронное программирование в Python. Поскольку асинхронное программирование строится на идее сопрограмм, то для начала вспомним, что это такое. Согласно Википедии "[сопрограмма](https://ru.wikipedia.org/wiki/%D0%A1%D0%BE%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B0) - это методика связи программных модулей друг с другом по принципу кооперативной многозадачности: модуль приостанавливается в определённой точке, сохраняя полное состояние (включая стек вызовов и счётчик команд), и передаёт управление другому. Тот, в свою очередь, выполняет задачу и передаёт управление обратно, сохраняя свои стек и счётчик". Если упростить это определение, то сопрограммы - это функции, которые могут останавливать свое выполнение и впоследствии возобновлять с точки останова. Именно так работают генераторы в Python. 

Генераторы появились в [Python 2.2](https://docs.python.org/3/whatsnew/2.2.html) ([PEP 255](https://www.python.org/dev/peps/pep-0255/)) и изначально реализуют интерфейс [итераторов](https://docs.python.org/3/library/stdtypes.html#iterator-types). Основной причиной появления генераторов была необходимость писать более эффективный код для итерации по генерируемым последовательностям. До появления генераторов реализация обхода последовательности обычно реализовывалась с помощью списка:

    def get_squares(number):
        """Возвращает корни чисел от 1 до указанного.

        :param number: Число, до которого включительно 
        нужно получить список корней.
        :return: Список корней.
        """
        result = []
        value = 1
        while value <= number:
            result.append(value * value)
            value += 1
        return result

    for square in get_squares(100):
        print('Square: %s' % square)

У такого подхода есть серьезный недостаток. Если нам не требуется получить сразу все 100 корней, то создание списка для их хранения выглядит избыточным. А что, если нам нужно вычислить 1,000,000,000 корней? А если это не просто числа, а объекты с внушительным содержимым? Тогда нам бы пришлось создать список из всех этих элементов и поместить туда все объекты сразу. А для этого может понадобиться приличный объем памяти, что выглядит совсем неэффективным. Конечно, можно было бы написать класс, который эмулирует интерфейс итератора, вроде:

    class GetSquares:
        """Класс эмулирует интерфейс итератора."""

        def __init__(self, number):
            self._number = number
            self._value = 0

        def next(self):
            if self._value == self._number:
                return None
            self._value += 1
            return self._value * self._value

    squares = GetSquares(100)
    while True:
        square = squares.next()
        if square is None:
            break

        print('Square: %s' % square)

Хотя класс и позволяет сэкономить на памяти (в момент времени создается и хранится только один элемент), такой подход не назовешь простым. Хотелось что-нибудь "из коробки". Этим "из коробки" и стало ключевое слово `yield`. Замена `return` в обычной функции на `yield` позволило превратить функцию в итератор. Теперь пример выше можно было переписать вот так:

    def get_squares(number):
        """Возвращает корни чисел от 1 до указанного.

        :param number: Число, до которого включительно 
        нужно получить список корней.
        :return: Итерируемый объект, который выдает 
        корни всех чисел.
        """
        value = 1
        while value <= number:
            yield value * value
            value += 1

    for square in get_squares(100):
        print('Square: %s' % square)

В месте вызова функции выполнение тела функции не происходит. Вместо этого возвращается объект типа `generator`. Выполнение функции начинается в момент вызова метода `next`  у генератора (в Python 3 он переименован в магический метод `__next__`), который является частью интерфейса итератора. Когда интерпретатор доходит до оператора `yield`, он останавливает выполнение функции и возвращает значение, переданное в оператор, обратно в вызываемый код. Цикл выше можно было бы для наглядности переписать так:

    generator = get_squares(100)
    while True:
        try:
            square = generator.next()
        except StopIteration:
            break

        print('Square: %s' % square)

Цикл `for` по сути неявно вызывает метод `next` и корректно обрабатывает исключение `StopIteration` в момент, когда генератор исчерпал свою последовательность. Из примера видно, что нам больше не нужен список для хранения элементов, а генератор позволяет вычислять необходимое значение только тогда, когда вызываемому его коду это значение действительно понадобится.

Появление генераторов позволило останавливать выполнение функции на операторе `yield` и возвращать значение из `yield` в вызываемый код. Но для реализации сопрограмм не хватало двунаправленного обмена данными, проще говоря, не хватало возможности передавать значения из вызываемого кода обратно в генератор. Такой механизм был добавлен в [Python 2.5](https://docs.python.org/3/whatsnew/2.5.html) ([PEP 342](https://www.python.org/dev/peps/pep-0342/)). В PEP 342 генераторы получили метод `send`, который позволил отправлять значение обратно в генератор. Для этого оператор `yield` пришлось превратить в выражение, поскольку только выражение может вычислять и возвращать значение. Возможность отправлять данные в генератор позволила управлять выполнением генератора из вызываемого кода. К примеру, в функцию `get_squares` мы теперь можем добавить возможность перехода к нужному шагу:

    def get_squares(number):
        """Возвращает корни чисел от 1 до указанного числа.

        Функция возвращает генератор последовательности 
        корней чисел от 1 до указанного в аргументе. Также 
        имеет возможность задавать позицию последовательности 
        вызовом метода send.
        :param number: Максимальное число, до которого 
        необходимо вычислить корень.
        """
        value = 1
        while value <= number:
            new_value = yield value * value
            print('get_squares: value %s new_value %s' % (value, new_value))
            if new_value is None:
                value += 1
                print('get_squares: after increment %s' % value)
            else:
                value = new_value
                print('get_squares: set from send %s' % value)

    generator = get_squares(5)
    print('Square of 1 is %s' % generator.next())
    print('Square of 2 is %s' % generator.next())
    print('Square of 3 is %s' % generator.next())
    print('Send 1 and square of 1 is %s' % generator.send(1))
    print('Square of 2 is %s' % generator.next())
    print('Send 5 and square of 5 is %s' % generator.send(5))

В процессе выполнения мы получим следующий вывод:

    >>> Square of 1 is 1
    >>> get_squares: value 1 new_value None
    >>> get_squares: after increment 2
    >>> Square of 2 is 4
    >>> get_squares: value 2 new_value None
    >>> get_squares: after increment 3
    >>> Square of 3 is 9
    >>> get_squares: value 3 new_value 1
    >>> get_squares: set from send 1
    >>> Send 1 and square of 1 is 1
    >>> get_squares: value 1 new_value None
    >>> get_squares: after increment 2
    >>> Square of 2 is 4
    >>> get_squares: value 2 new_value 5
    >>> get_squares: get from send 5
    >>> Send 5 and square of 5 is 25

Я специально добавил несколько вызовов `print` внутри функции-генератора, чтобы можно было проследить всю последовательность выполнения. Как видно из вывода, мы можем отправлять значение в генератор и использовать его там для управления потоком выполнения. Для эффективного управления потоком не хватало возможности выстраивать генераторы в цепочки вызовов. Допустим, у нас есть функция-генератор:

    def generator():
        for i in range(2):
            yield i

Перебор значений и возврат каждого из другой функции-генератора можно было реализовать как-то так:

    def another_generator():
        for j in generator():
            yield j

У такого кода есть один большой недостаток - он не позволяет передать значение во внутренний генератор, отправленное методом `send`, во внешний генератор. Например, вот это работать не будет:

    def generator():
        while True:
            sent_value = yield
            print('Sent value is %s' % sent_value)

    def another_generator():
        for j in generator():
            yield j

    gen = another_generator()
    next(gen)
    gen.send(1)

Если выполнить код, то получим вот это:

    >>> Sent value is None

Чтобы добиться передачи значения, приходилось писать сложную обвязку, которая учитывает работу генератора, корректно обрабатывает `StopIteration` при завершении генератора и так далее. Насколько сложным получался такой код, можно оценить по [этому псевдокоду](https://www.python.org/dev/peps/pep-0380/#formal-semantics). А если необходима была многократная вложенность, то в итоге все становилось совсем печально.

Чтобы упростить это, в [Python 3.3](https://docs.python.org/3/whatsnew/3.3.html) добавили выражение `yield from` ([PEP 380](https://www.python.org/dev/peps/pep-0380/)). Это выражение принимает итератор и выдает каждое значение из него так, как будто этот итератор находится в текущей функции-генераторе. После появления `yield from` строить цепочки из генераторов стало намного проще:

    def generator():
        while True:
            sent_value = yield
            print('Sent value is %s' % sent_value)

    def another_generator():
        # теперь у нас есть yield from :)
        yield from generator()

    gen = another_generator()
    next(gen)
    gen.send(1)

И это то, что требовалось:

    >>> Sent value is 1

Выражение `yield from` позволило прозрачно передавать значение извне сразу в конечный генератор, независимо от того, сколько вызовов `yield from` находится до него. Эта особенность позволила создавать цепочку из генераторов, в которой переданные значения могли всплывать и опускаться обратно по стэку вызовов без какого-либо дополнительного кода. Пример ниже реализует бесконечный генератор корней и демонстрирует использование `yield from` для выстраивания цепочки генераторов:

    def calculate_root():
        # получаем первое значение
        number = yield
        while True:
            # тут же вычисляем корень
            # и отдаем его обратно
            number = yield number * number

    def get_square1():
        yield from calculate_root()

    def get_square2():
        yield from get_square1()

    generator = get_square2()
    next(generator)
    print('Square of 2 is {}'.format(generator.send(2)))
    print('Square of 5 is {}'.format(generator.send(5)))
    print('Square of 10 is {}'.format(generator.send(10)))

В результате выполнения кода в консоль будет выведен текст:

    >>> Square of 2 is 4
    >>> Square of 5 is 25
    >>> Square of 10 is 100

Как итог, уже в Python 2.5 появилась возможность писать асинхронный код, используя `yield`, а в Python 3.3 с появлением `yield from` и возможности строить из генераторов цепочки это стало еще проще.

## Что такое event loop и зачем оно в Python?
Без понимания работы event loop понять, как работает `async`/`await`, не получится. Кто уже знаком с этой концепцией, может смело пропускать этот раздел. Итак, event loop - это подход, при котором некая программная конструкция следит за возникновением событий от других частей программы, и при появлении таких событий вызывает соответствующий код для их обработки. По сути event loop позволяет реализовать логику "когда случилось что-то, выполни то-то". Самый простой пример - обработка нажатий кнопки мыши на сайте в браузере. При нажатии пользователем на любую кнопку на сайте происходит событие, которое отправляется в event loop. Event loop пытается выяснить, что необходимо с ним сделать. Для этого он просматривает список всех зарегистрированных обработчиков и, если находит подходящий, вызывает его для обработки этого события. Если же обработчика найти не удается, событие просто игнорируется. Все события, возникающие в программе, выстраиваются в очередь и event loop обрабатывает их в порядке поступления. Как только все события обработаны и в очереди ничего не осталось, event loop переходит в фазу ожидания. При поступлении события все повторяется. И так происходит постоянно, пока программа выполняется. Обработчиками событий обычно выступают функции обратного вызова (callback-функции).

До появления `asyncio` в Python отсутствовала реализация event loop по умолчанию. Пакет [`asyncio`, представленный в Python 3.4](https://docs.python.org/3.4/library/asyncio.html), добавил этот функционал в стандартную библиотеку языка. `asyncio` является 
фреймворком для написания асинхронных приложений на базе event loop. Основной упор в `asyncio` сделан на сетевой ввод/вывод. Как пример, в качестве "когда случилось что-то" может выступать событие готовности сокета к чтению и/или записи (см. [модуль `selectors`](https://docs.python.org/3/library/selectors.html#module-selectors)). Однако, ничто не мешает использовать его, например, в качестве планировщика для организации исполнения кода в отдельном потоке или дочернем процессе. Что и представляет собой [кооперативная многозадачность](https://ru.wikipedia.org/wiki/%D0%9C%D0%BD%D0%BE%D0%B3%D0%BE%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%BD%D0%BE%D1%81%D1%82%D1%8C).


## А при чем тут async/await?
### Как это было в Python 3.4
